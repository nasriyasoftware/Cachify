import FileCacheRecord from "./file";
import type { Prettify, RequiredStrict } from "@nasriya/atomix";
import type { TTLFileOptions } from "../../configs/strategies/ttl/TTLConfig";

type FileTypeMap = {
    options: {
        normal: {
            /**
             * Whether or not to emit a 'preload' event when the record is created.
             * If not provided, the default preload behavior from the cache's configuration is used.
             * 
             * This property is intended to be used when the cache manager
             * loads the records from persistent storage.
             * @private
             * @since v1.0.0
             */
            preload?: false;

            /**
             * The scope of the record.
             * If not provided, the default scope from the cache's configuration is used.
             * @default 'global'
             * 
             * @example
             * cachify.files.set('/path/to/file', { scope: 'assets' });
             * @since v1.0.0
             */
            scope?: string;

            /**
             * A custom key for the record. If not provided, the key is generated by encoding the file path in base64.
             * 
             * This is useful when you want to set the key as the file URL for cross-platform compatibility.
             * @example
             * cachify.files.set('/path/to/file', { key: 'custom_key' });
             * @since v1.0.0
             */
            key?: string;

            /**
             * Specifies the storage engine(s) where this cache record should be stored.
             *
             * Each value must match the name of a registered engine (e.g., "memory", "redis", or a custom-defined name).
             * If multiple engines are provided, the record will be written to all of them. When reading, the system will
             * attempt to read from the engines in the order they are listed.
             *
             * If this field is not provided, the record will default to being stored only in the "memory" engine.
             *
             * @example
             * storeIn: 'memory' // Store in memory only
             * storeIn: ['redis'] // Store in Redis only
             * storeIn: ['memory', 'redis'] // Store in both, prefer memory for reads
             *
             * @since v1.0.0
             */
            storeIn?: string | string[];

            /**
             * The time to live in milliseconds for the record. Must be at least `5000` ms
             * or a `TTLFileOptions` object.
             * 
             * @example
             * cachify.files.set('key', 'value', { ttl: 5000 });
             * @example
             * cachify.files.set('key', 'value', { ttl: { value: 5000, onExpire: (record) => console.log(`Record ${record.key} has expired.`) } });
             * @since v1.0.0
             */
            ttl?: number | TTLFileOptions;
        };

        preload: {
            restore: Prettify<{ preload: true, initiator: 'restore' } & Omit<FileCacheRecordExportedData, 'value' | 'flavor' | 'engines' | 'ttl'> & { ttl: TTLFileOptions; storeIn: string[] }>;
            warmup: Prettify<{ preload: true, initiator: 'warmup' } & Omit<FileTypeMap['options']['normal'], 'preload' | 'ttl' | 'storeIn'> & { ttl?: TTLFileOptions; storeIn?: string[] }>;
        }
    }

    configs: {
        normal: Prettify<RequiredStrict<
            Omit<FileTypeMap['options']['normal'], 'ttl' | 'storeIn'>
        > & { ttl: TTLFileOptions; storeIn: string[] }>;

        preload: {
            restore: Prettify<Omit<FilePreloadRestoreSetOptions, 'engines' | 'ttl'> & { storeIn: string[]; ttl: TTLFileOptions }>;
            warmup: Prettify<RequiredStrict<Omit<FilePreloadWarmupSetOptions, 'ttl'>> & { ttl: TTLFileOptions }>;
        }
    }
}

// =======================================================================
// Set configs
export type FileSetConfigs = FileNormalSetConfigs | FilePreloadSetConfigs;
export type FilePreloadSetConfigs = FilePreloadRestoreSetConfigs | FilePreloadWarmupSetConfigs;

export type FilePreloadWarmupSetConfigs = FileTypeMap['configs']['preload']['warmup'];
export type FilePreloadRestoreSetConfigs = FileTypeMap['configs']['preload']['restore'];
export type FileNormalSetConfigs = FileTypeMap['configs']['normal'];

// =======================================================================
// Set options
export type FileSetOptions = FileNormalSetOptions | FilePreloadSetOptions;
export type FilePreloadSetOptions = FilePreloadRestoreSetOptions | FilePreloadWarmupSetOptions;
export type FilePreloadWarmupSetOptions = FileTypeMap['options']['preload']['warmup'];
export type FilePreloadRestoreSetOptions = FileTypeMap['options']['preload']['restore'];
export type FileNormalSetOptions = FileTypeMap['options']['normal'];

export type FileStats = {
    mtime: number;
    size: number;
};

interface FileBaseOptions {
    /**
     * The scope of the record.
     * If not provided, the default scope from the cache's configuration is used.
     * @default 'global'
     * 
     * @example
     * cachify.files.set({ scope: 'assets', key: 'custom_key' });
     */
    scope?: string;
}

export interface FilePathOptions extends FileBaseOptions {
    /**
     * The file path to read.
     * @example
     * cachify.files.read({ filePath: '/path/to/file' });
     */
    filePath: string;
}

export interface FileKeyOptions extends FileBaseOptions {
    /**
     * The key of the record to read.
     * @example
     * cachify.files.read({ key: 'custom_key' });
     */
    key: string;

    /**
     * Whether to perform a case-sensitive search.
     * @default true
     */
    caseSensitive?: boolean;
}

export type FileOptions = FilePathOptions | FileKeyOptions

export interface FileCacheReadResponse {
    /**
     * The status of the read operation.
     * If the content is available, it is a hit.
     * If the content is not available, it is a miss.
     * It's about whether the content is cached or not, not whether the
     * record has been read before.
     */
    status: 'hit' | 'miss';

    /**
     * The content of the file.
     */
    content: Buffer
}

export type FileCacheRecordExportedData = Exclude<Awaited<ReturnType<FileCacheRecord['export']>>, undefined>;